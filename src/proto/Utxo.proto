syntax = "proto3";

package TW.Utxo.Proto;
option java_package = "wallet.core.jni.proto";

import "Common.proto";

enum Error {
    OK = 0;
    Error_invalid_wpkh_script_pubkey = 1;
    Error_invalid_leaf_hash = 2;
    Error_invalid_sighash_type = 3;
    Error_invalid_lock_time = 4;
    Error_invalid_txid = 5;
    Error_sighash_failed = 6;
    Error_missing_sighash_method = 7;
    Error_failed_encoding = 8;
    Error_insufficient_inputs = 9;
    Error_missing_change_script_pubkey = 10;
    Error_zero_sequence_not_enabled = 11;
}

message SigningInput {
    // The protocol version, is currently expected to be 1 or 2 (BIP68)
    int32 version = 1;

    // Block height or timestamp indicating at what point transactions can be
    // included in a block.
    LockTime lock_time = 2;

    // The inputs of the transaction to sign. If an individual input does not
    // provide an index, then the index of the inserted order is used.
    repeated TxIn inputs = 3;

    repeated TxOut outputs = 4;

    InputSelector input_selector = 5;

    // The base unit per weight. In the case of Bitcoin, that would refer to
    // satoshis ("satVb").
    uint64 weight_base = 6;

    bytes change_script_pubkey = 7;

    // Explicility disable change output creation.
    bool disable_change_output = 8;
}

enum InputSelector {
    UseAll = 0;
    SelectInOrder = 1;
    SelectAscending = 2;
}

message LockTime {
    oneof variant {
        uint32 blocks = 1;
        uint32 seconds = 2;
    }
}

message TxIn {
    // The referenced transaction hash.
    bytes txid = 1;

    // The index of the referenced output.
    uint32 vout = 2;

    uint64 value = 3;

    uint32 sequence = 4;

    // Explicitly allow a `sequence` of zero.
    bool sequence_enable_zero = 5;

    // The spending condition of the output.
    bytes script_pubkey = 6;

    // The sighash type.
    SighashType sighash_type = 7;

    SigningMethod signing_method = 8;

    uint64 weight_estimate = 9;

    bytes leaf_hash = 10;
}

enum SigningMethod {
    Legacy = 0;
    Segwit = 1;
    TaprootAll = 2;
    TaprootOnePrevout = 3;
}

enum SighashType {
    // Use default (All)
    UseDefault = 0; // 0x00
    // Sign all outputs.
    All = 1; // 0x01
    // Sign no outputs, anyone can choose the destination.
    None = 2; // 0x02
    // Sign the output whose index matches this inputs index.
    Single = 3; // 0x03
    //Sign all outputs but only this input.
    AllPlusAnyoneCanPay = 129; // 0x81
    // Sign no outputs and only this input.
    NonePlusAnyoneCanPay = 130; // 0x82
    // Sign one output and only this input.
    SinglePlusAnyoneCanPay = 131; // 0x83
}

// The output of a transaction.
message TxOut {
    // The value of the output.
    uint64 value = 1;
    // The spending condition of the output.
    bytes script_pubkey = 2;
}

message PreSigningOutput {
    // error code, 0 is ok, other codes will be treated as errors
    Error error = 1;

    /// Sighashes to be signed; ECDSA for legacy and Segwit, Schnorr for Taproot.
    repeated Sighash sighashes = 2;

    repeated TxIn inputs = 3;

    repeated TxOut outputs = 4;

    uint64 weight_estimate = 5;

    uint64 fee_estimate = 6;
}

message Sighash {
    bytes sighash = 1;
    SigningMethod signing_method = 2;
    SighashType sighash_type = 3;
}

message PreSerialization {
    // The protocol version, is currently expected to be 1 or 2 (BIP68)
    int32 version = 1;

    // Block height or timestamp indicating at what point transactions can be
    // included in a block.
    LockTime lock_time = 2;

    // The transaction inputs containing the serialized claim scripts.
    repeated TxInClaim inputs = 3;

    // The transaction outputs.
    repeated TxOut outputs = 4;

    // The base unit per weight. In the case of Bitcoin, that would refer to
    // satoshis ("satVb").
    uint64 weight_base = 5;
}

message TxInClaim {
    // The referenced transaction hash.
    bytes txid = 1;

    // The index of the referenced output.
    uint32 vout = 2;

    // The sequence number (TODO).
    uint32 sequence = 3;

    // The script used for claiming an input.
    bytes script_sig = 4;

    // The script used for claiming an input.
    repeated bytes witness_items = 5;
}

message SerializedTransaction {
    // error code, 0 is ok, other codes will be treated as errors
    Error error = 1;

    // The encoded transaction, ready to be submitted to the network.
    bytes encoded = 2;

    // The transaction ID.
    bytes txid = 3;

    uint64 weight = 4;

    uint64 fee = 5;
}
